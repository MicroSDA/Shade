#BasicModel
#vertex
#version 440
mat3 CalculateTBNMatrix(mat4 ModelMatrix, vec3 Normals, vec3 Tangents)
{
	vec3 T = normalize(vec3(ModelMatrix * vec4(Tangents, 0.0)));
	vec3 N = normalize(vec3(ModelMatrix * vec4(Normals, 0.0)));
	T = normalize(T - dot(T, N) * N);
	vec3 B = normalize(cross(T, N));

	if (dot(cross(N, T), B) > 0.0)
             T = T * -1.0;

	return mat3(T, B, N);
}

	layout (location = 0) in vec3 Position;
	layout (location = 1) in vec2 TextureCoords;
	layout (location = 2) in vec3 Normals;
	layout (location = 3) in vec3 Tangents;
	
	uniform mat4 ModelMatrix;
	uniform mat4 ViewMatrix;
	uniform mat4 ProjectionMatrix;
	uniform vec3 CameraPosition;
		
	layout (location = 0) out vec2 out_TextureCoords;
    layout (location = 1) out vec3 out_Normals;
	layout (location = 2) out vec3 out_CameraPosition;
	layout (location = 3) out vec3 out_ModelPosition;

	out mat3 out_TBN;

	void main()
	{
		gl_Position = ProjectionMatrix * ViewMatrix * ModelMatrix *  vec4(Position, 1.0f);
	    out_TBN =  CalculateTBNMatrix(ModelMatrix, Normals, Tangents);
		out_TextureCoords = TextureCoords;
		out_Normals  = (ModelMatrix * vec4(Normals, 0.0)).xyz;
		out_ModelPosition = (ModelMatrix * vec4(Position, 1.0f)).xyz;
        out_CameraPosition  = CameraPosition;
	}
#end
#fragment
#version 440
struct BaseLight
{
   vec3  Direction;
   vec3  ColorAmbient;
   vec3  ColorDiffuse;
   vec3  ColorSpecular;
   float ShininesStrength; // move To material
};
struct PointLight 
{
   BaseLight Light;
   vec3  Position;
   float Constant;
   float Linear;                                                                   
   float Qaudratic;    
};
struct SpotLight
{
  PointLight Light;
  float      MinAngle;
  float      MaxAngle;
};
struct Material 
{
   vec3  colorAmbient;
   vec3  colorDiffuse;
   vec3  colorSpecular;
   vec3  transparentMask;
   float shinines;
   float shininesStrength;
 
};

uniform BaseLight         generalL;
uniform PointLight        pointL;
uniform SpotLight         spotL;
uniform Material          material;

vec4 ProcessGeneralLight(vec3 Normals, BaseLight Light, Material material, vec3 ToCameraDirection, vec4 DiffuseTexture, vec4 SpecularTexture)
{                                                          //Material
    vec4  m_AmbientColor   = vec4((DiffuseTexture.rgb * material.colorAmbient * Light.ColorAmbient), DiffuseTexture.a);
    vec4  m_DiffuesColor   = vec4(0.0, 0.0, 0.0, 0.0);
    vec4  m_SpecularColor  = vec4(0.0, 0.0, 0.0, 0.0);

    float m_DiffuesShading = dot(Normals, -Light.Direction);

    if(m_DiffuesShading > 0.0)
    {                                                       // Material
       m_DiffuesColor          = vec4((DiffuseTexture.rgb * material.colorDiffuse * Light.ColorDiffuse * m_DiffuesShading), DiffuseTexture.a);
       vec3 LightReflect       = normalize(reflect(Light.Direction, Normals)); // normalize(reflect(Light.Direction, Normals));
       float m_SpecularShading = dot(ToCameraDirection, LightReflect);

       if(m_SpecularShading > 0.0)
       {
          m_SpecularShading = pow(m_SpecularShading, material.shinines);
                                                         //Material
          m_SpecularColor = vec4((SpecularTexture.rgb * material.colorSpecular * Light.ColorSpecular * material.shininesStrength * m_SpecularShading), SpecularTexture.a);
      }

    }

    return vec4(m_AmbientColor + m_DiffuesColor + m_SpecularColor);
}

vec4 ProcessPointLight(vec3 Normals, PointLight pointLight, Material material, vec3 ModelPosition, vec3 ToCameraDirection, vec4 DiffuseTexture, vec4 SpecularTexture)
{
    vec3  m_LightDirection  = ModelPosition - pointLight.Position;
    float m_Distance        = length(m_LightDirection);
    m_LightDirection        = normalize(m_LightDirection);
    PointLight m_Light      = pointLight;
    m_Light.Light.Direction = m_LightDirection;

    vec4  m_Color = ProcessGeneralLight(Normals, m_Light.Light, material, ToCameraDirection, DiffuseTexture, SpecularTexture);
    float m_Attenuation =  pointLight.Constant + pointLight.Linear * m_Distance + pointLight.Qaudratic * (m_Distance * m_Distance);

    return m_Color / m_Attenuation;
}

vec4 ProcessSpotLight(vec3 Normals, SpotLight spotLight, Material material, vec3 ModelPosition, vec3 ToCameraDirection, vec4 DiffuseTexture, vec4 SpecularTexture)
{
    const float m_Smooth = 2; // Harcoded 
    vec3  m_LightDirection = normalize(ModelPosition - spotLight.Light.Position);
    float m_SpotFactor     = dot(m_LightDirection,  spotLight.Light.Light.Direction);
    
    if (m_SpotFactor > spotLight.MaxAngle)
    { 
        float m_Epsilon     = spotLight.MinAngle - spotLight.MaxAngle;
        m_SpotFactor        = smoothstep(0.0, m_Smooth, (m_SpotFactor - spotLight.MaxAngle) / m_Epsilon);
        SpotLight m_Light   = spotLight;
        vec4 m_Color        = ProcessPointLight(Normals, spotLight.Light, material, ModelPosition, ToCameraDirection, DiffuseTexture, SpecularTexture);
        return m_Color * m_SpotFactor;
    }
    else
    {
        return vec4(0, 0, 0, 0);
    }
}
vec3 CalculateTBNNormal(vec3 NormalMap, mat3 TBNMatrix)
{
   vec3 m_TBNNormal = NormalMap;
   m_TBNNormal = 2.0 * m_TBNNormal  - vec3(1.0, 1.0, 1.0);   
   m_TBNNormal = normalize(TBNMatrix * m_TBNNormal);
   return m_TBNNormal;
}

	layout(binding = 0) uniform sampler2D DIFFUSE_TEXTURE;
	layout(binding = 1) uniform sampler2D SPECULAR_TEXTURE;
	layout(binding = 2) uniform sampler2D NORMAL_MAP;
	
	layout (location = 0) in vec2 TextureCoords;
	layout (location = 1) in vec3 Normals;
	layout (location = 2) in vec3 CameraPosition;
	layout (location = 3) in vec3 ModelPosition;


	layout (location = 0) out vec4 ColorAttachment1;
	layout (location = 1) out int ColorAttachment2;
	
	in mat3 out_TBN;

	void main()
	{
	    vec3 TBNNormal = CalculateTBNNormal(texture(NORMAL_MAP, TextureCoords).rgb, out_TBN);
	
		vec3 ToCameraDirection = normalize(CameraPosition - ModelPosition);

	    //vec4 m_TotalColor = ProcessGeneralLight(TBNNormal, generalL, material, ToCameraDirection, texture(DIFFUSE_TEXTURE, TextureCoords).rgba, texture(SPECULAR_TEXTURE, TextureCoords).rgba);
		vec4 m_TotalColor = ProcessPointLight(TBNNormal, pointL, material, ModelPosition, ToCameraDirection, texture(DIFFUSE_TEXTURE, TextureCoords).rgba, texture(SPECULAR_TEXTURE, TextureCoords).rgba);
		//vec4 m_TotalColor = ProcessSpotLight(TBNNormal, spotL, material, ModelPosition, ToCameraDirection, texture(DIFFUSE_TEXTURE, TextureCoords).rgba, texture(SPECULAR_TEXTURE, TextureCoords).rgba);
		
		ColorAttachment1 = vec4(pow(m_TotalColor.rgb, vec3(0.70/1)), m_TotalColor.a);
		ColorAttachment2 = 10;
	}
#end
#---